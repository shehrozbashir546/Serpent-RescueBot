
#include <stdio.h>
#include <stdlib.h>

int checking(char* world, int* robot_index, int* width, int* target_index) {

   int a = robot_index - width - 1;
   int b = robot_index + width + 1;
   int c = robot_index + 1;
   int d = robot_index - 1;  }
    


int move(char* world) {
    // copy the array into a new one to get the size

    char world2[200];
    for (int i = 0; i < 200; i++) {
        world2[i] = world[i];
    }

    unsigned int elements = sizeof(world2) / sizeof(world2[0]);
    int robot_index;
    int target_index;
    int lines = 0;
    int width = 20;

    
    for (int i = 0; i < elements; ++i) { //index of R
        if (world2[i] == 'R') {
            robot_index = i;
            break;
        }
    }
    
    for (int i = 0; i < elements; ++i) { //index of T
        if (world2[i] == 'T') {
            target_index = i;
            break;
        }
    }

    //if T has bigger position index than R in the array
    if (robot_index < target_index) {
        //distance between indexes of R and T
        int distance = target_index - robot_index;

        //count how many lines between R and T
        for (int i = robot_index; i < target_index; ++i) {
            if (world2[i] == '\n') {
                lines++;
            }
        }

        //as long as R is above T, go down, until it reaches the same line.
        do {
            for (int i = 0; i < lines; i++) {
                return 3;
            }
        } while (lines > 0);

        //while R is on same line of T, go right.
        do {
            for (int i = 0; i < distance; i++) {
                return 2;
            }
        } while (lines < 1 && distance > 0);




        //while R is on the same line of T, go left.
        do {
            for (int i = 0; i < distance; i++) {
                return 4;
            }
        } while (lines < 1 && distance < 0);
    }



    //if T has smaller position index than R in the array
    else if (robot_index > target_index) {
        //distance between indexes of R and T
        int distance = robot_index - target_index;
        //count how many lines between R and T
        for (int i = target_index; i < robot_index; ++i) {
            if (world2[i] == '\n') {
                lines++;
            }
        }

        do {
            for (int i = 0; i < lines; i++) {
               
                    return 1;}
               // else { int a = robot_index - width - 1;
               // printf("THIS IS A = % c", world[a]);
              //  }
                
            
        } while (lines > 0);

        //while R is on the same line of T, go left
        do {
            for (int i = 0; i < distance; i++) {
                return 4;
            }
        } while (lines < 1 && distance > 0);

        //while R is on same line of T, go right.
        do {
            for (int i = 0; i < distance; i++) {
                return 2;
            }
        } 
        while (lines < 1 && distance < 0);
    }
}

// Return target index
int update_world(int movement, char* world, int robot_index, int width) {
    int target_index = 0;
    // NORTH
    if (movement == 1) {
        target_index = robot_index - (width + 1); // +1 for the newline
    }
    // SOUTH
    else if (movement == 3) {
        target_index = robot_index + (width + 1); // +1 for the newline
    }
    // EAST
    else if (movement == 2) {
        target_index = robot_index + 1;
    }
    // WEST
    else if (movement == 4) {
        target_index = robot_index - 1;
    }

    // ACTION
    if (world[target_index] == 'O') {
        world[target_index] = 'R';
        world[robot_index] = 'O';
        return target_index;
    }
    else if (world[target_index] == '#') {
        printf("%s", world);
        printf("%c", '\n');
        printf("FAILURE, crashed into a wall!");
        exit(1);
    }
    else if (world[target_index] == 'T') {
        world[target_index] = 'R';
        world[robot_index] = 'O';
        printf("%s", world);
        printf("%c", '\n');
        printf("GREAT SUCCESS, target found!");
        exit(0);
    }
}

int main() {
    const int MAX_STEPS = 200;
    int step = 1;

    int movement;
    int width = 20; // excluding newlines
  
    // The world 
    char world[200] = {
        '#','#','#','#','#','#','#','#','#','#','#','#','#','#','#','#','#','#','#','#','\n',
        '#','O','O','O','O','O','O','O','O','O','O','O','O','O','O','O','O','O','O','#','\n',
        '#','O','O','O','O','#','#','#','#','#','O','O','O','O','O','O','O','O','O','#','\n',
        '#','O','O','O','O','#','T','O','O','#','O','O','O','O','O','O','O','O','O','#','\n',
        '#','O','O','O','O','#','#','#','O','#','O','O','O','O','O','O','O','O','O','#','\n',
        '#','O','O','O','O','O','O','O','O','O','O','O','O','O','O','O','O','O','O','#','\n',
        '#','O','O','O','O','O','O','O','O','O','O','R','O','O','O','O','O','O','O','#','\n',
        '#','#','#','#','#','#','#','#','#','#','#','#','#','#','#','#','#','#','#','#','\n'
    };

    // Initialize target and robot positions
    // Assumes only one target, one robot
    unsigned int elements = sizeof(world) / sizeof(world[0]);

    // Initialize the index of the robot and the target.
    // Assumes exactly one robot and one target
    int robot_index;
    int target_index;

    for (int i = 0; i < elements; ++i) {
        if (world[i] == 'R') {
            robot_index = i;
            break;
        }
    }
    for (int i = 0; i < elements; ++i) {
        if (world[i] == 'T') {
            target_index = i;
            break;
        }
    }

    // Print the initial world
    printf("Starting position: %c", '\n');
    // Debug output
    // printf("Robot index: %i / target index: %i %c", robot_index, target_index, '\n');
    printf("%s", world);
    printf("%c", '\n');

    while (step <= MAX_STEPS) {
        printf("After step number %i: %c", step, '\n');

        movement = move(world);
        robot_index = update_world(movement, world, robot_index, width);
        printf("%s", world);
        printf("%c", '\n');
        step = step + 1;
    }
    if (step >= MAX_STEPS) {
        printf("FAILURE, maximum number of steps exceeded.");
    }

}
